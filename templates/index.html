<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAG Text Segment Annotator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; }
        .container { display: flex; border: 1px solid #ccc; }
        .navigator { width: 200px; border-right: 1px solid #ccc; padding: 10px; }
        .editor { flex: 1; padding: 10px; }
        .header { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .node-item { margin-bottom: 5px; padding: 5px; border: 1px solid #ddd; display: flex; }
        .node-details { width: 50%; padding-right: 10px; }
        .edges-container { width: 50%; padding-left: 10px; border-left: 1px solid #eee; }
        .edge-item { margin-bottom: 5px; border-bottom: 1px dotted #ccc; padding-bottom: 5px; }
        .btn { padding: 2px 2px; cursor: pointer; }
        select, input { margin: 2px 0; padding: 0px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="navigator">
            <h3>Document List</h3>
            <div id="file-list"></div>
        </div>
        <div class="editor">
            <div class="header">
                <h2>DAG Annotator</h2>
                <div>
                    <button id="graph-btn" class="btn">Show Graph</button>
                    <button id="save-btn" class="btn">Save</button>
                </div>
            </div>
            <div id="doc-content">
                <p>No document selected. Please choose a document from the list.</p>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentDocId = '';
        let currentDoc = null;
        let nodeLabels = null; // Example labels
        let edgeLabels = null; // Example edge labels
        let nodeColors = null;

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            loadFileList();
            document.getElementById('save-btn').addEventListener('click', saveAnnotation);

            // Update nodeLabels and edgeLabels dynamically
            fetch('/get_labels')
                .then(response => response.json())
                .then(data => {
                    nodeLabels = data.node_labels;
                    edgeLabels = data.edge_labels;
                    nodeColors = data.node_colors
                })
                .catch(error => console.error('Error fetching labels:', error));

            // Get doc_id from URL and fetch data from backend
            const params = new URLSearchParams(window.location.search);
            const docId = params.get('doc_id');
            console.log('docId:', docId);
            if (docId) {
                loadDocument(docId);
            }
        });

        // Load list of JSON files
        function loadFileList() {
            fetch('/load_file_list')
                .then(response => response.json())
                .then(files => {
                    const fileListElement = document.getElementById('file-list');
                    fileListElement.innerHTML = '';
                    
                    files.forEach(file => {
                        const fileItem = document.createElement('div');
                        fileItem.textContent = file;
                        fileItem.style.cursor = 'pointer';
                        fileItem.style.padding = '5px';
                        fileItem.addEventListener('click', () => loadDocument(file));
                        fileListElement.appendChild(fileItem);
                    });
                })
                .catch(error => console.error('Error loading file list:', error));
        }

        // Load document
        function loadDocument(docId) {
            currentDocId = docId;
            fetch(`/load_document?doc_id=${docId}`)
                .then(response => response.json())
                .then(data => {
                    currentDoc = data;
                    renderDocument(data);
                })
                .catch(error => console.error('Error loading document:', error));
        }

        // Render document content
        function renderDocument(doc) {
            const contentElement = document.getElementById('doc-content');
            contentElement.innerHTML = '';

            // Add document ID and raw text
            const docIdElement = document.createElement('h3');
            docIdElement.textContent = `Document ID: ${doc.doc_id}`;
            contentElement.appendChild(docIdElement);

            // Render nodes section
            const nodesSection = document.createElement('div');
            nodesSection.innerHTML = '<h3>Nodes</h3>';
            contentElement.appendChild(nodesSection);

            // Ensure edges array exists
            if (!doc.edges) {
                doc.edges = [];
            }

            // Render each node
            doc.nodes.forEach((node, nodeIndex) => {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node-item';
                
                // Create node details column (left side)
                const nodeDetailsElement = document.createElement('div');
                nodeDetailsElement.className = 'node-details';
                
                const nodeText = document.createElement('div');
                nodeText.textContent = `${node.id}: "${node.text}"`;
                nodeDetailsElement.appendChild(nodeText);
                
                // Node label dropdown
                const labelContainer = document.createElement('div');
                labelContainer.innerHTML = `<label>Node Label: </label>`;
                
                const labelSelect = document.createElement('select');
                labelSelect.id = `node-label-${node.id}`;
                
                // Add empty option
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Select label';
                labelSelect.appendChild(emptyOption);
                
                // Add node label options
                nodeLabels.forEach(label => {
                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    option.selected = node.label === label;
                    labelSelect.appendChild(option);
                });

                // if node.annotation is False, disable this dropdown
                if (node.annotation === false) {
                    labelSelect.disabled = true;
                }
                
                labelContainer.appendChild(labelSelect);
                nodeDetailsElement.appendChild(labelContainer);
                
                // Add event listener for label change
                labelSelect.addEventListener('change', (e) => {
                    const nodeIndex = doc.nodes.findIndex(n => n.id === node.id);
                    if (nodeIndex !== -1) {
                        doc.nodes[nodeIndex].label = e.target.value;
                    }
                });
                labelSelect.addEventListener('change', () => handleNodeSelection(node.id));
                labelSelect.addEventListener('change', saveAnnotation);
                
                // Add node details to the main node element
                nodeElement.appendChild(nodeDetailsElement);
                
                // Create edges column (right side)
                const edgesContainer = document.createElement('div');
                edgesContainer.className = 'edges-container';
                
                if (node.annotation) {  // Skip for the first node as it can't have incoming edges
                    const edgesHeader = document.createElement('div');
                    edgesHeader.innerHTML = '<strong>Incoming Edges:</strong>';
                    edgesContainer.appendChild(edgesHeader);
                    
                    // Get edges where this node is the target
                    const nodeEdges = doc.edges.filter(edge => edge.to_node_id === node.id);
                    
                    // Render existing edges
                    nodeEdges.forEach(edge => {
                        const edgeElement = createEdgeElementForNode(edge, node.id);
                        edgesContainer.appendChild(edgeElement);
                    });
                    
                    // Add edge button
                    const addEdgeBtn = document.createElement('button');
                    addEdgeBtn.textContent = 'Add Edge';
                    addEdgeBtn.className = 'btn';
                    addEdgeBtn.addEventListener('click', () => {
                        // find the edge ID that is not present in doc.edges
                        const newEdgeId = doc.edges.length ? Math.max(...doc.edges.map(e => parseInt(e.id.substring(1)))) + 1 : 1;
                        const newEdge = {
                            id: `e${newEdgeId}`,
                            from_node_id: '',
                            to_node_id: node.id,
                            label: ''
                        };
                        doc.edges.push(newEdge);
                        const edgeElement = createEdgeElementForNode(newEdge, node.id);
                        edgesContainer.insertBefore(edgeElement, addEdgeBtn);
                    });
                    edgesContainer.appendChild(addEdgeBtn);

                    // Split button
                    const splitBtn = document.createElement('button');
                    splitBtn.textContent = 'Split';
                    splitBtn.className = 'btn';
                    splitBtn.addEventListener('click', () => {
                        // generate a textarea with label as pre-inputted text
                        const splitText = document.createElement('textarea');
                        splitText.value = node.text;
                        splitText.style.width = '100%';
                        splitText.style.height = 'auto';
                        splitText.style.overflowY = 'hidden';
                        splitText.addEventListener('input', () => {
                            splitText.style.height = 'auto';
                            splitText.style.height = `${splitText.scrollHeight}px`;
                        });
                        // add a save button
                        const saveSplitBtn = document.createElement('button');
                        saveSplitBtn.textContent = 'Save';
                        saveSplitBtn.className = 'btn';
                        saveSplitBtn.addEventListener('click', () => {
                            // call split_node API
                            fetch('/split_node', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    doc: currentDoc,
                                    node_id: node.id,
                                    new_text: splitText.value
                                })
                            })
                            // reload the document
                            .then(response => response.json())
                            .then(data => {
                                loadDocument(currentDocId);
                            })
                            .catch(error => console.error('Error splitting node:', error));
                        });
                        const splitInstruction = document.createElement('p');
                        splitInstruction.textContent = 'Enter | character right before where the second node starts';
                        edgesContainer.appendChild(splitInstruction);
                        edgesContainer.appendChild(splitText);
                        edgesContainer.appendChild(saveSplitBtn);
                    });
                    edgesContainer.appendChild(splitBtn);
                    
                    
                    // Split button
                    const mergeBtn = document.createElement('button');
                    mergeBtn.textContent = 'Merge with above';
                    mergeBtn.className = 'btn';
                    mergeBtn.addEventListener('click', () => {
                        // call split_node API
                        fetch('/merge_node', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                doc: currentDoc,
                                node_id: node.id
                            })
                        })
                        // reload the document
                        .then(response => response.json())
                        .then(data => {
                            loadDocument(currentDocId);
                        })
                        .catch(error => console.error('Error merge node:', error))
                    });
                    edgesContainer.appendChild(mergeBtn);
                }
                
                
                // Add edges container to the main node element
                nodeElement.appendChild(edgesContainer);
                
                // Add the complete node element to the nodes section
                nodesSection.appendChild(nodeElement);
                
                // Trigger handleNodeSelection
                handleNodeSelection(node.id);
            });
        }
        
        // event handler function for node selection
        // change the 'node-item' bgcolor with the nodeColor[selected node label]
        function handleNodeSelection(nodeId) {
            const nodeLabelSelect = document.getElementById(`node-label-${nodeId}`);
            const parentNodeItem = nodeLabelSelect.closest('.node-item');
            if (nodeLabelSelect && parentNodeItem) {
                const selectedLabel = nodeLabelSelect.value;
                if (selectedLabel && nodeColors[selectedLabel]) {
                    parentNodeItem.style.backgroundColor = nodeColors[selectedLabel];
                } else {
                    parentNodeItem.style.backgroundColor = '';
                }
            }
        }

        // Create edge element for a specific node
        function createEdgeElementForNode(edge, toNodeId) {
            const edgeElement = document.createElement('div');
            edgeElement.className = 'edge-item';
            edgeElement.id = `edge-${edge.id}`;
            
            // From node dropdown (only showing nodes that precede this one)
            const fromNodeContainer = document.createElement('div');
            fromNodeContainer.innerHTML = `<label>From Node: </label>`;
            
            const fromNodeSelect = document.createElement('select');
            fromNodeSelect.id = `edge-from-${edge.id}`;
            
            // Add empty option
            const emptyFromOption = document.createElement('option');
            emptyFromOption.value = '';
            emptyFromOption.textContent = 'Select node';
            fromNodeSelect.appendChild(emptyFromOption);
            
            // Find the target node index
            const toNodeIndex = currentDoc.nodes.findIndex(n => n.id === toNodeId);
            
            // Add only preceding nodes as options
            currentDoc.nodes.slice(0, toNodeIndex).forEach(node => {
                const option = document.createElement('option');
                option.value = node.id;
                // add ellipsis to textContent to prevent overflow
                // option.textContent = `${node.id}: ${node.text}`;
                option.textContent = `${node.id}: ${node.text.length > 97 ? node.text.substring(0, 97) + '...' : node.text}`;
                option.selected = edge.from_node_id === node.id;
                fromNodeSelect.appendChild(option);
            });

            // make select fit within the box, considering the fromNodeContainer's children <label>'s width
            fromNodeSelect.style.width = `calc(100% - 100px)`;
            fromNodeSelect.style.textOverflow = 'ellipsis';

            fromNodeContainer.appendChild(fromNodeSelect);
            edgeElement.appendChild(fromNodeContainer);
            
            // Edge label dropdown
            const labelContainer = document.createElement('div');
            labelContainer.innerHTML = `<label>Edge Label: </label>`;
            
            const labelSelect = document.createElement('select');
            labelSelect.id = `edge-label-${edge.id}`;
            
            // Add empty option
            const emptyLabelOption = document.createElement('option');
            emptyLabelOption.value = '';
            emptyLabelOption.textContent = 'Select label';
            labelSelect.appendChild(emptyLabelOption);
            
            // Add edge label options
            edgeLabels.forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                option.selected = edge.label === label;
                labelSelect.appendChild(option);
            });
            
            labelContainer.appendChild(labelSelect);
            edgeElement.appendChild(labelContainer);
            
            // Delete edge button
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'btn';
            deleteBtn.addEventListener('click', () => {
                const edgeIndex = currentDoc.edges.findIndex(e => e.id === edge.id);
                if (edgeIndex !== -1) {
                    currentDoc.edges.splice(edgeIndex, 1);
                    renderDocument(currentDoc);
                }
            });
            edgeElement.appendChild(deleteBtn);
            
            // Add event listeners for edge changes
            fromNodeSelect.addEventListener('change', (e) => {
                const edgeIndex = currentDoc.edges.findIndex(ed => ed.id === edge.id);
                if (edgeIndex !== -1) {
                    currentDoc.edges[edgeIndex].from_node_id = e.target.value;
                }
            });
            fromNodeSelect.addEventListener('change', saveAnnotation);
            
            labelSelect.addEventListener('change', (e) => {
                const edgeIndex = currentDoc.edges.findIndex(ed => ed.id === edge.id);
                if (edgeIndex !== -1) {
                    currentDoc.edges[edgeIndex].label = e.target.value;
                }
            });
            labelSelect.addEventListener('change', saveAnnotation);
            
            return edgeElement;
        }

        // Save annotation
        function saveAnnotation() {
            if (!currentDoc) {
                alert('No document loaded');
                return;
            }
            
            // Update node labels
            currentDoc.nodes.forEach(node => {
                const labelSelect = document.getElementById(`node-label-${node.id}`);
                if (labelSelect) {
                    node.label = labelSelect.value;
                }
            });
            
            // Send data to server
            fetch('/save_annotation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(currentDoc)
            })
            .then(response => response.json())
            .then(data => {
                console.log(data.message || 'Annotation saved');
            })
            .catch(error => {
                console.error('Error saving annotation:', error);
                alert('Error saving annotation');
            });
        }

        // When graph button is clicked, call GET /graph_visualization with doc_id param as current doc ID
        document.getElementById('graph-btn').addEventListener('click', () => {
            if (currentDocId) {
                window.location.href = `/graph?doc_id=${currentDocId}`;
            } else {
                alert('No document loaded');
            }
        });
    </script>
</body>
</html>